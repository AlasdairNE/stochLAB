#' Stochastic migration collision risk model for a single species and one turbine scenario
#'
#' Run migration stochastic collision risk model for a single species and one turbine scenario
#'
#' @details
#' This function is an adaption of code from Masden(2015) used for estimating
#' the collision risk of seabirds in offshore windfarm sites and is a further
#' adaptation from Band(2012). It is a further adaptation of the stoch_crm function.
#'
#' The collision risk model evaluates risk for each defined migratory period where
#' flux rate is simply the number of birds travelling through the windfarm.
#'
#' Changes in relation to previous top-line function \code{stoch_crm}
#' \itemize{
#'   \item function will run only option 1 for migratory species#'
#' }
#'
#'
#' @return Estimates of number of collisions per migratory season
#'
#' @param n_turbines integer
#' @param BirdData A data frame. Contains all the parameters for the species
#' @param TurbineData A data frame. Contains all the parameters for the turbines
#' @param CountData A data frame. Contains density data for the wind farm of interest
#' @param FlightData A data frame. Contains flight height data for species
#' @param iter An integer constant > 0. The number of stochastic draws to take
#' @param spp_name A character vector.
#' @param TPower A decimal value. The amount of power generated by the wind farm (MW)
#' @param LargeArrayCorrection A boolean. If TRUE, correct if the wind farm array is very large
#' @param WFWidth A decimal value. The "width" of wind farm used in Large Array Correction (KM)
#' @param Prop_Upwind A decimal value. A value between 0-1 bounded as proportion of flights upwind - default of 0.5.
#' @param Latitude. A decimal value. Latitude in WGS 1984 (decimal degrees)
#' @param TideOff A decimal value. Tidal offset in metres
#' @param windSpeedMean A decimal value. Site specific mean wind speed (m/s)
#' @param windSpeedSD A decimal value. Site specific standard deviation of wind speeds
#' @param windData_rotation A data frame. The table of wind speed versus rotor speed
#' @param windData_pitch A data frame. The table of wind speed versus rotor pitch
#' @param dens_opt A character value. The type of sampling to do for the species density data.
#'
#' @import msm
#' @import dplyr
#' @import tidyr
#' @import pracma
#'
#' @examples
#'
#' @export
#'
mig_stoch_crm <- function(
                      BirdData, TurbineData, CountData,
                      iter = 10,
                      spp_name,
                      LargeArrayCorrection,
                      n_turbines,
                      WFWidth,
                      Prop_Upwind,
                      Latitude,
                      TideOff,
                      windSpeedMean,
                      windSpeedSD,
                      windData_rotation,
                      windData_pitch,
                      fhd_bootstraps = NULL,
                      dens_opt = "truncNorm"
                      #DensityOpt = list(userOption = "truncNorm")
) {


  start.time <- Sys.time()

  # Global variables   ---------------------------------------------------------
  model_months <- month.abb
  n_months <- length(model_months)

  # Chord taper profile based on the blade of a typical 5 MW turbine used for
  # offshore generation. Required for `p_single_collision` function
  chord_profile <- data.frame(
    # radius at bird passage point, as a proportion of rotor radius (R)
    pp_radius = seq(0.05, 1, 0.05),
    # chord width at pp_radius, as a proportion of the maximum chord width
    chord = c(0.73, 0.79, 0.88, 0.96, 1.00, 0.98, 0.92, 0.85, 0.80, 0.75,
              0.70, 0.64, 0.58, 0.52, 0.47,0.41, 0.37, 0.30,0.24,0.00)
  )


  # Initiate objects to harvest results ----------------------------------------
  sampledBirdParams <- list()

  scrm_outputs <- list()
  for(i in model_options){
    scrm_outputs[[paste0("opt", i)]] <-
      data.matrix(
        matrix(data = NA, ncol = n_months, nrow = iter,
               dimnames = list(NULL, model_months))
      )
  }

  # Prepare inputs  ------------------------------------------------------------

  ## For the migration app we make the assumption to be precautionary, that the animals are
  ## passing through the windfarm area during the day time.
  ## Thus, flux is simply a count of the number of birds passing through the area
  ## as per the simulation outputs

  ## month labels
  monthLabels <- month.abb

  ## join rotation and pitch data into a single table
  windData <- dplyr::left_join(windData_rotation,windData_pitch,by='windSpeed')
  windThreshold <- windData$windSpeed[min(which(windData$rotationSpeed != 0))]

  ## bird inputs
  species.dat = BirdData

  species.dat$FlightNumeric <- ifelse(species.dat$Flight == 'Flapping', 1, 0) # TODO: check if correct as spreadsheet 3 indicates 1 for gliding...
  Flap_Glide = ifelse (species.dat$Flight == "Flapping", 1, 2/pi)

  if(dens_opt == "truncNorm"){
    species.count = subset(CountData, Species == spp_name)
  }


  # Generate random draws of parameters  ---------------------------------------
  #
  # TODO: consider reworking densities sampling interface

  ## sample bird attributes

  sampledBirdParams$WingSpan <- sampler_hd(dat = species.dat$WingspanSD,
                                           mode = 'rtnorm',
                                           n = iter,
                                           mean=species.dat$Wingspan,
                                           sd = species.dat$WingspanSD,
                                           lower = 0)

  sampledBirdParams$BodyLength <- sampler_hd(dat = species.dat$Body_LengthSD,
                                             mode = 'rtnorm',
                                             n = iter,
                                             mean=species.dat$Body_Length,
                                             sd = species.dat$Body_LengthSD,
                                             lower = 0)


  sampledBirdParams$FlightSpeed <- sampler_hd(dat = species.dat$Flight_SpeedSD,
                                              mode = 'rtnorm',
                                              n = iter,
                                              mean=species.dat$Flight_Speed,
                                              sd = species.dat$Flight_SpeedSD,
                                              lower = 0)

  sampledBirdParams$PCH <- sampler_hd(dat = species.dat$Prop_CRH_ObsSD,
                                      mode = 'rbeta',
                                      n = iter,
                                      mean=species.dat$Prop_CRH_Obs,
                                      sd = species.dat$Prop_CRH_ObsSD)


  sampledBirdParams$NocturnalActivity <- sampler_hd(dat = species.dat$Nocturnal_ActivitySD,
                                                    mode = 'rbeta',
                                                    n = iter,
                                                    mean=species.dat$Nocturnal_Activity,
                                                    sd = species.dat$Nocturnal_ActivitySD)


  sampledBirdParams$AvoidanceBasic <- sampler_hd(dat = species.dat$AvoidanceBasicSD,
                                                 mode = 'rbeta',
                                                 n = iter,
                                                 mean=species.dat$AvoidanceBasic,
                                                 sd = species.dat$AvoidanceBasicSD)



  ## sample monthly densities

  if(dens_opt == "truncNorm"){
    for(currentMonth in month.abb){
      # separate out the current month mean and SD. Species.count is already filtered for current species
      workingMean <- species.count %>% dplyr::select(contains(currentMonth),-contains('SD'))
      workingSD <- species.count %>% dplyr::select(contains(paste0(currentMonth,"SD")))
      sampledSpeciesCount[,grep(currentMonth, names(sampledSpeciesCount))] <- sampler_hd(dat = data.frame(workingSD)[1,1],
                                                                                         mode = 'rtnorm',
                                                                                         n = iter,
                                                                                         mean=data.frame(workingMean)[1,1],
                                                                                         sd = data.frame(workingSD)[1,1])
    }
  }

  if(dens_opt == "reSamp"){
    for(currentMonth in monthLabels){
      workingVect <- dplyr::sample_n(tbl = species.count %>% dplyr::select(contains(currentMonth)), size = iter, replace = TRUE)
      sampledSpeciesCount[,grep(currentMonth, names(sampledSpeciesCount))] <- workingVect
    }
  }

  if(dens_opt == "pcntiles"){
    for(currentMonth in monthLabels){
      cPcntls <- species.count %>% dplyr::select(referenceProbs, contains(currentMonth))
      workingVect <- sampleCount_pctiles(iter, probs = cPcntls[, 1], countsPctls = cPcntls[, 2])
      sampledSpeciesCount[,grep(currentMonth, names(sampledSpeciesCount))] <- workingVect
    }
  }

  # convert to data.matrix for improved performance
  sampledSpeciesCount <- data.matrix(sampledSpeciesCount)

  ## turbine parameters

  ## function where the row gets passed in for sampling
  sampledTurbine <- sample_turbine(TurbineData,
                                   windSpeedMean = windSpeedMean,
                                   windSpeedSD = windSpeedSD,windData,
                                   windThreshold,iter)

  ## sample monthly operational proportion
  # convert from % to proportion
  sampled_oper_prop <- sampledTurbine %>%
    select(contains("Op", ignore.case = F)) %>%
    dplyr::mutate(dplyr::across(everything(), ~ .x/100)) %>%
    data.matrix()

  sampled_avg_oper_prop <- apply(sampled_oper_prop, 1, mean)


  # Iterating over sampled parameters  -----------------------------------------

  for (i in 1:iter){

    # Collision risk steps -----------------------------------------------------

    # STEP 1 - Calculate probability of collision for a single rotor transit in
    #          the absence of avoidance [Stage C in Band (2012)]

    p_single_collision <-
      get_prob_collision(
        chord_prof = chord_profile,
        flight_speed = sampledBirdParams$FlightSpeed[i],
        body_lt = sampledBirdParams$BodyLength[i],
        wing_span = sampledBirdParams$WingSpan[i],
        prop_upwind = Prop_Upwind,
        flap_glide = Flap_Glide,
        rotor_speed = sampledTurbine$RotorSpeed[i],
        rotor_radius = sampledTurbine$RotorRadius[i],
        blade_width = sampledTurbine$BladeWidth[i],
        blade_pitch = sampledTurbine$Pitch[i],
        n_blades = Turbine_Data$Blades
      )


    # STEP 2 - Set up Large Array Correction Factor -----
    if (LargeArrayCorrection == TRUE) {
      L_ArrayCF <-
        get_lac_factor(
          n_turbines = n_turbines,
          rotor_radius = sampledTurbine$RotorRadius[i],
          avoidance_rate = sampledBirdParams$AvoidanceBasic[i],
          prob_single_collision = p_single_collision,
          mean_prop_operational = sampled_avg_oper_prop[i],
          wf_width = WFWidth
        )
    } else{
      # set multiplier to 1 to dismiss large array correction
      L_ArrayCF <- 1
    }


    # STEP 3 - flux per season -----------------------------------

    flux_fct <-
      get_flux_factor(
        n_turbines = n_turbines,
        rotor_radius = sampledTurbine$RotorRadius[i],
        flight_speed = sampledBirdParams$FlightSpeed[i],
        bird_dens = sampledSpeciesCount[i, ],
        daynight_hrs = daynight_hrs_month,
        noct_activity = sampledBirdParams$NocturnalActivity[i]
      )

    scrm_outputs$opt1[i, ] <-
      crm_opt1(
        flux_factor = flux_fct,
        prop_crh_surv = sampledBirdParams$PCH[i],
        prob_single_collision = p_single_collision,
        prop_operational = sampled_oper_prop[i, ],
        avoidance_rate = sampledBirdParams$AvoidanceBasic[i],
        lac_factor = L_ArrayCF)

  } # end of i to iter

  scrm_outputs


}

