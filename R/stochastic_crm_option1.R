#' Translation of Masden 2015 collision risk models for offshore wind collisions
#'
#' This function is an adaption of code from Masden(2015) used for estimating the collision risk of seabirds in
#' offshore windfarm sites and is a further adaptation from Band(2012).
#'
#'
#' @param results_folder A character string. Path name to an existing output folder for tables/plots
#' @param BirdDataFile A data frame. Contains all the parameters for the species
#' @param TurbineDataFile A data frame. Contains all the parameters for the turbines
#' @param CountDataFile A data frame. Contains density data for the wind farm of interest
#' @param FlightDataFile A data frame. Contains flight height data for species
#' @param iter An integer constant > 0. The number of stochastic draws to take
#' @param CRSpecies A character vector. List of species to consider. Looks to match/define other species name, so must match throughout
#' @param TPower A decimal value. The amount of power generated by the wind farm (MW)
#' @param LargeArrayCorrection A character vector. Correct for a large array? "yes" or "no"
#' @param WFWidth A decimal value. The "width" of wind farm used in Large Array Correction (KM)
#' @param Prop_Upwind A decimal value. A value between 0-1 bounded as proportion of flights upwind - default of 0.5.
#' @param Latitude. A decimal value. Latitude in WGS 1984 (decimal degrees)
#' @param TideOff A decimal value. Tidal offset in metres
#' @param windSpeedMean A decimal value. Site specific mean wind speed (m/s)
#' @param windSpeedSD A decimal value. Site specific standard deviation of wind speeds
#' @return CSV files saved into the results_folder directory
#' @export
#' @import msm
#' @import dplyr
#' @import tidyr
#' @import pracma
#' @import data.table
#'


stochasticBand <- function(
  results_folder = NULL,
  BirdDataFile = BirdDataFile,
  TurbineDataFile = TurbineDataFile,
  CountDataFile = CountDataFile,
  FlightDataFile = FlightDataFile,
  iter = 10,
  CRSpecies = c("Black_legged_Kittiwake"),
  TPower = 1760,
  LargeArrayCorrection = "yes",
  WFWidth = 54,
  Prop_Upwind = 0.5,
  Latitude = 53.7,
  TideOff = 2.5,
  windSpeedMean = 30,
  windSpeedSD = 5.1,
  windData_rotation = startUpValues$turbinePars$rotationVsWind_df,
  windData_pitch = startUpValues$turbinePars$pitchVsWind_df,
  #updateProgress_Spec,  # pass in the updateProgress function so that it can update the progress indicator.
  #updateProgress_Iter,
  DensityOpt = list(userOption = "truncNorm")
) {

  #S<-iter*20 ## this is number of samples, increased to ensure enough valid values - is this used?

  #### BC ##### -- initialise objects to store simulation replicates of monthly collisions, for each option, for current species and turbine  ===========
  monthCollsnReps_opt1 <- list()
  monthCollsnReps_opt2 <- list()
  monthCollsnReps_opt3 <- list()


  # Create folders and paths ------------------------------------------------
  if(is.null(results_folder)){
    stop("Please supply a value for results_folder")
  }

  # ###create results folder
  # if(results_folder == "") results_folder<- Sys.Date() ## if no name given for results folder, use today's date
  # if(results_folder !="") dir.create(results_folder) ## if name given for results folder use that and create folder      #####    BC CHANGE  -- folder created beforehand by app  ######

  ##make input, figures and tables folders
  dir.create(paste(results_folder, "figures", sep="/"))
  dir.create(paste(results_folder, "tables", sep="/"))
  dir.create(paste(results_folder, "input", sep="/"))

  monthLabels <- month.abb

  # Join rotation and pitch data into a single table ------------------------
  windData <- left_join(windData_rotation,windData_pitch,by='windSpeed')
  windThreshold <- windData$windSpeed[min(which(windData$rotationSpeed != 0))]  ##GH change (ROTOR to rotationSpeed)

  # set the row names of the bird data and assign flapping/gliding ----------
  #row.names(BirdData) <-  BirdData$Species
  #### flapping or Gliding for collision risk sheet
  Flap_Glide <- ifelse (BirdData$Flight == "Flapping", 1, 2/pi)  ### <- DO WE NEED THIS?!?


  #### produces a data frame with number of hours daylight and night per month based on the latitude
  hours <- DayLength(Latitude)


  ##### bring in call functions needed to calculate collision risk along blade
  ### Turned off for Option 1 GH - Needs updating
  #source("scripts/PCollFunctions.r", local=T)


  # calculations ------------------------------------------------------------

  ##set progress bar
  #pb   <- txtProgressBar(1, iter*length(CRSpecies)*nrow(TurbineData), style=3)

  ###create overall results summary table###
  resultsSummary = data.frame(matrix(data = 0, ncol = 8, nrow = length(CRSpecies)*nrow(TurbineData)))
  names(resultsSummary) = c("Species", "Turbine", "Option", "Mean", "SD","CV", "Median", "IQR")

  # Start of the species loop -----------------------------------------------

  for (s in 1 : length (CRSpecies)){
    ###CREATE BIRD PARAMETER DATA FRAME###
    sampledBirdParams = data.frame(matrix(data = 0, ncol = 7, nrow = iter))
    names(sampledBirdParams) = c("AvoidanceBasic", "AvoidanceExtended",  "WingSpan", "BodyLength", "PCH", "FlightSpeed", "NocturnalActivity")

    ###CREATE COUNT/DENSITY DATA FRAME###
    sampledSpeciesCount = data.frame(matrix(data = 0, ncol = 12, nrow = iter))
    names(sampledSpeciesCount) = month.abb

    ###CREATE DATA FRAME FOR DENSITY DATA###
    densitySummary=data.frame(matrix(data = 0, ncol = nrow(TurbineData)*3, nrow = iter))


    #### BC ##### -- progress bar update for iterations    ===========
    #if (is.function(updateProgress_Spec)) {
    #  text <- gsub("_", " ", CRSpecies[s])
    #  updateProgress_Spec(value = s/(length(CRSpecies)), detail = text)
    #}

    species.dat = subset (BirdData, Species == CRSpecies[s])

    species.dat$FlightNumeric <- ifelse(species.dat$Flight == 'Flapping', 1, 0)
    Flap_Glide = ifelse (species.dat$Flight == "Flapping", 1, 2/pi)


    c_densOpt <- dplyr::filter(DensityOpt, specLabel == CRSpecies[s])$userOption  ### <- work on this

    if(c_densOpt == "truncNorm"){
      species.count = subset(CountData, Species == CRSpecies[s])
    }


    if(c_densOpt == "reSamp"){
      species.count <- fread("data/birdDensityData_samples.csv") %>%
        filter(specLabel == CRSpecies[s])
    }


    if(c_densOpt == "pcntiles"){
      species.count <- fread("data/birdDensityData_refPoints.csv") %>%
        filter(specLabel == CRSpecies[s])
    }



    ##input flight curves for the species
    #################################
    #### TURNED OFF FOR OPTION 1 ####

    #ht<-paste("data/", CRSpecies[s],"_ht.csv", sep='')

    #FlightHeightSpec <- read.csv(ht, header = T) #and change in option2 code

    #flight.boot <- 2:dim(FlightHeightSpec)[2]     ##### BC CHANGE  -- need to skip first column with heights ######

    #flight.boot.sample <- sample(flight.boot, iter, replace=T)
    ###########################################################################################


    ##add names of columns later in turbine loop###


    # Sample the bird attributes ----------------------------------------------
    ### Streamlined by GH 19 July 2021.
    sampledBirdParams$WingSpan <- sampler_hd(dat = species.dat$WingspanSD,
                                             mode = 'rtnorm',
                                             n = iter,
                                             mean=species.dat$Wingspan,
                                             sd = species.dat$WingspanSD,
                                             lower = 0)

    sampledBirdParams$BodyLength <- sampler_hd(dat = species.dat$Body_LengthSD,
                                               mode = 'rtnorm',
                                               n = iter,
                                               mean=species.dat$Body_Length,
                                               sd = species.dat$Body_LengthSD,
                                               lower = 0)


    sampledBirdParams$FlightSpeed <- sampler_hd(dat = species.dat$Flight_SpeedSD,
                                                mode = 'rtnorm',
                                                n = iter,
                                                mean=species.dat$Flight_Speed,
                                                sd = species.dat$Flight_SpeedSD,
                                                lower = 0)

    sampledBirdParams$PCH <- sampler_hd(dat = species.dat$Prop_CRH_ObsSD,
                                        mode = 'rbeta',
                                        n = iter,
                                        mean=species.dat$Prop_CRH_Obs,
                                        sd = species.dat$Prop_CRH_ObsSD)


    sampledBirdParams$NocturnalActivity <- sampler_hd(dat = species.dat$Nocturnal_ActivitySD,
                                                      mode = 'rbeta',
                                                      n = iter,
                                                      mean=species.dat$Nocturnal_Activity,
                                                      sd = species.dat$Nocturnal_ActivitySD)


    sampledBirdParams$AvoidanceBasic <- sampler_hd(dat = species.dat$AvoidanceBasicSD,
                                                   mode = 'rbeta',
                                                   n = iter,
                                                   mean=species.dat$AvoidanceBasic,
                                                   sd = species.dat$AvoidanceBasicSD)

    sampledBirdParams$AvoidanceExtended <- sampler_hd(dat = species.dat$AvoidanceExtendedSD,
                                                      mode = 'rbeta',
                                                      n = iter,
                                                      mean=species.dat$AvoidanceExtended,
                                                      sd = species.dat$AvoidanceExtendedSD)



    # Monthly density estimates sampled here --------------------------------------------

    if(c_densOpt == "truncNorm"){
      for(currentMonth in month.abb){
        # separate out the current month mean and SD. Species.count is already filtered for current species
        workingMean <- species.count %>% dplyr::select(contains(currentMonth),-contains('SD'))
        workingSD <- species.count %>% dplyr::select(contains(paste0(currentMonth,"SD")))
        sampledSpeciesCount[,grep(currentMonth, names(sampledSpeciesCount))] <- sampler_hd(dat = data.frame(workingSD)[1,1],
                                                                                           mode = 'rtnorm',
                                                                                           n = iter,
                                                                                           mean=data.frame(workingMean)[1,1],
                                                                                           sd = data.frame(workingSD)[1,1])
      }
    }


    if(c_densOpt == "reSamp"){
      for(currentMonth in monthLabels){
        workingVect <- dplyr::sample_n(tbl = species.count %>% dplyr::select(contains(currentMonth)), size = iter, replace = TRUE)
        sampledSpeciesCount[,grep(currentMonth, names(sampledSpeciesCount))] <- workingVect
      }
    }



    if(c_densOpt == "pcntiles"){
      for(currentMonth in monthLabels){
        cPcntls <- species.count %>% dplyr::select(referenceProbs, contains(currentMonth))
        workingVect <- sampleCount_pctiles(iter, probs = cPcntls[, 1], countsPctls = cPcntls[, 2])
        sampledSpeciesCount[,grep(currentMonth, names(sampledSpeciesCount))] <- workingVect
      }
    }


    # Start of turbine loop ---------------------------------------------------
    for (j in 1:nrow(TurbineData))  {   ## GH CHANGE <- t is a function, replaced this with j

      ## create results tables - 3 identical
      tab1 <- data.frame(matrix(data = 0, ncol = 12, nrow = iter))
      names(tab1) <- monthLabels
      tab2 <- tab3 <- tab1

      ###set vectors to store PCol and CollInt###
      sampledPColl <- data.frame(matrix(data = 0, ncol = 1, nrow = iter))
      names(sampledPColl) <- "PColl"

      sampledCollInt <- data.frame(matrix(data = 0, ncol = 1, nrow = iter))
      names(sampledCollInt) <- "CollInt"

      ## GH streamlined code to a function where the row gets passed in for sampling
      sampledTurbine <- sample_turbine(TurbineData[j,],windData,windThreshold,iter)

      MonthlyOperational <- sampledTurbine %>% select(contains("Op", ignore.case = F))
      MeanOperational <- apply(MonthlyOperational, 1, mean)

      # Iterating i - over random samples  --------------------------------------

      for (i in 1:iter){

        #### BC ##### -- progress bar update for iterations    ===========
        #if (is.function(updateProgress_Iter)) {
        #  text <- NULL # paste0("Working through iteration ", i)
        #  updateProgress_Iter(value = i/iter, detail = text)
        #}

        # fixed turbine pars
        currentBlades <- TurbineData$Blades

        # sampled turbine pars
        currentRotorRadius <- sampledTurbine$RotorRadius[i]
        currentBladeWidth <- sampledTurbine$BladeWidth[i]
        currentRotorSpeed <- sampledTurbine$RotorSpeed[i]
        currentPitch <- sampledTurbine$Pitch[i]

        # fixed bird parameter
        currentFlightNumeric <- species.dat$FlightNumeric

        # sampled bird parameters
        currentWingSpan <- sampledBirdParams$WingSpan[i]
        currentFlightSpeed <- sampledBirdParams$FlightSpeed[i]
        currentBirdLength <- sampledBirdParams$BodyLength[i]

        # Collision risk steps - options appear here ------------------------------

        ############## STEP ONE - Calculate the collision risk in the absence of avoidance action

        #source("scripts/ProbabilityCollision.r", local=T)


        ############## STEP TWO - Calculate Flux Factor - the number of birds passing a turbine in each month


        ## First calculate turbine frontal area

        NTurbines = round (TPower / TurbineData$TurbineModel[j]) ### Number of turbines of given Output required to produce target output
        TotalFrontalArea = NTurbines * pi * sampledTurbine$RotorRadius[i] ^2

        #### Calculate the total number of birds passing through the wind farm in each month

        ### LAPPLY (VECTORIZE)
        for (h in 1:nrow(hours)) {

          hours$Flux[h] = sampledBirdParams$FlightSpeed[i] * sampledSpeciesCount[i, h]/ (2 * sampledTurbine$RotorRadius[i]) * TotalFrontalArea *
            (hours$Day[h] + sampledBirdParams$NocturnalActivity[i] * hours$Night[h]) * 3600/1000000

        }


        ############## STEP THREE - Calculate Large Array Correction Factor

        ## calculate number of turbine rows - manually enter if appropriate

        NTurbRows = NTurbines ^ 0.5


        CollRiskSinglePassage = NTurbines * (pi * sampledTurbine$RotorRadius[i]^2)/(2 * sampledTurbine$RotorRadius[i] * WFWidth * 1000) *
          (P_Collision/100) * (MeanOperational[i]/100) * (1-sampledBirdParams$AvoidanceBasic[i])

        L_ArrayCF = 1 - (NTurbRows - 1) / (2*NTurbRows) * CollRiskSinglePassage +
          (NTurbRows - 1) * (2*NTurbRows)/(6 * NTurbRows^2) * (CollRiskSinglePassage ^2)



        # Option 1 ----------------------------------------------------------------


        #######################		Do model using option 1 - Site specific flight height information	###############################

        #source("scripts/Option1.r", local=T)

        ## add results to overall species/turbine results table
        tab1[i,]=Option1_CollisionRate[,2]

        #store P_Coll
        sampledPColl[i,]<-P_Collision/100


        # Option 2 ----------------------------------------------------------------


        #######################		Do model using option 2 - modelled flight height distribution		###############################



        #source("scripts/Option2.r", local=T)
        ## add results to overall species/turbine results table
        tab2[i,]=Option2_CollisionRate[,2]


        # Option 3 ----------------------------------------------------------------


        #######################		Do model using option 3 - modelled flight height distribution		###############################
        #######################		taking account of variation in risk along the rotor blades		###############################

        #source("scripts/Option3.r", local=T)
        ## add results to overall species/turbine results table
        tab3[i,]=Option3_CollisionRate[,2]

        #Store Collision Integral
        sampledCollInt[i,]<-CollInt

        ##progress bar for iterations##
        #setTxtProgressBar(pb, s*t+i)
        #setTxtProgressBar(pb, (s*nrow(TurbineData)-(nrow(TurbineData)-t))*iter-(iter-i))


      } # end of i to iter

      # End of the random samplling iterations i --------------------------------


      #source("scripts/turbineSpeciesOuputs.r", local=T)

      #### BC ##### -- reset counter of progress bar for iterations =====================
      #if (is.function(updateProgress_Iter)) {
      #  text <- NULL # paste0("Working through iteration ", i)
      #  updateProgress_Iter(value = 0, detail = text)
      #}


      #### BC ##### -- Store simulation replicates under each option, for current species and turbine  ===========
      cSpec <- CRSpecies[s]
      cTurbModel <- paste0("turbModel", TurbineData$TurbineModel[j])

      monthCollsnReps_opt1[[cSpec]][[cTurbModel]] <- tab1
      monthCollsnReps_opt2[[cSpec]][[cTurbModel]] <- tab2
      monthCollsnReps_opt3[[cSpec]][[cTurbModel]] <- tab3

    } # end of t over number of turbine


    # End of the turbine loop -------------------------------------------------



    ###output species plots of density by option with curves for turbine model###
    ###PLOT DENSITY BY OPTION (useful if several turbine models)###

    if (nrow(TurbineData)>1)  {

      #source("scripts/species_turbine_plots.r", local = T)

    }

    ###relabel sampledBirdParams by species name###
    assign(paste(CRSpecies[s],"params", sep="_"), sampledBirdParams)

    ###relabel sampledSpeciesCount by species name###
    assign(paste(CRSpecies[s],"counts", sep="_"), sampledSpeciesCount)


  } # end of the species loop over s

  ##output input data##
  fwrite(BirdData, paste(results_folder,"input", "BirdData.csv", sep="/"))
  fwrite(CountData, paste(results_folder,"input", "birdDensityData.csv", sep="/"))      # <<<<< BC <<<<<  change of file name, for clarity
  fwrite(TurbineData, paste(results_folder,"input", "TurbineData.csv", sep="/"))

  ###output results table###
  fwrite(resultsSummary, paste(results_folder,"tables", "CollisionEstimates.csv", sep="/"))


  end.time <- Sys.time()
  run.time <- end.time - start.time
  run.time

  sink(paste(results_folder,"run.time.txt", sep="/"))
  print(run.time)
  print(paste("The model ran", iter,"iterations", sep=" "))
  print("The following species were modelled:")
  print(CRSpecies)
  print("The following turbines were modelled:")
  print(TurbineData$TurbineModel)
  sink()

  #### BC ##### -- return collision replicates as output  ===========
  return(list(monthCollsnReps_opt1 = monthCollsnReps_opt1, monthCollsnReps_opt2 = monthCollsnReps_opt2,
              monthCollsnReps_opt3 = monthCollsnReps_opt3))

}

