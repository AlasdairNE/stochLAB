#' Translation of Masden 2015 collision risk models for offshore wind collisions
#'
#' This function is an adaption of code from Masden(2015) used for estimating the collision risk of seabirds in
#' offshore windfarm sites and is a further adaptation from Band(2012).
#'
#'
#' @param results_folder A character string. Path name to an existing output folder for tables/plots
#' @param BirdData A data frame. Contains all the parameters for the species
#' @param TurbineData A data frame. Contains all the parameters for the turbines
#' @param CountData A data frame. Contains density data for the wind farm of interest
#' @param FlightData A data frame. Contains flight height data for species
#' @param iter An integer constant > 0. The number of stochastic draws to take
#' @param CRSpecies A character vector. List of species to consider. Looks to match/define other species name, so must match throughout
#' @param TPower A decimal value. The amount of power generated by the wind farm (MW)
#' @param LargeArrayCorrection A boolean. If TRUE, correct if the wind farm array is very large
#' @param WFWidth A decimal value. The "width" of wind farm used in Large Array Correction (KM)
#' @param Prop_Upwind A decimal value. A value between 0-1 bounded as proportion of flights upwind - default of 0.5.
#' @param Latitude A decimal value. Latitude in WGS 1984 (decimal degrees)
#' @param TideOff A decimal value. Tidal offset in metres
#' @param windSpeedMean A decimal value. Site specific mean wind speed (m/s)
#' @param windSpeedSD A decimal value. Site specific standard deviation of wind speeds
#' @param windData_rotation A data frame. The table of wind speed versus rotor speed
#' @param windData_pitch A data frame. The table of wind speed versus rotor pitch
#' @param c_densOpt A character value. The type of sampling to do for the species data.
#' @return CSV files saved into the results_folder directory
#' @export
#' @import msm
#' @importFrom dplyr select filter sample_n left_join
#' @import tidyr
#' @import pracma
#'
stochBand <- function(
  results_folder = NULL,
  BirdData = Bird_Data,
  TurbineData = Turbine_Data,
  CountData = Count_Data,
  FlightData = Flight_Data,
  iter = 10,
  CRSpecies = c("Black_legged_Kittiwake"),
  TPower = 1760,
  LargeArrayCorrection = TRUE,
  WFWidth = 54,
  Prop_Upwind = 0.5,
  Latitude = 53.7,
  TideOff = 2.5,
  windSpeedMean = 30,
  windSpeedSD = 5.1,
  windData_rotation = startUpValues$turbinePars$rotationVsWind_df,
  windData_pitch = startUpValues$turbinePars$pitchVsWind_df,
  #updateProgress_Spec,  # pass in the updateProgress function so that it can update the progress indicator.
  #updateProgress_Iter,
  c_densOpt = "truncNorm"
  #DensityOpt = list(userOption = "truncNorm")
) {

  start.time <- Sys.time()

  #### BC ##### -- initialise objects to store simulation replicates of monthly collisions, for each option, for current species and turbine  ===========
  monthCollsnReps_opt1 <- list()
  #monthCollsnReps_opt2 <- list()
  #monthCollsnReps_opt3 <- list()


  # Create folders and paths ------------------------------------------------
  if(is.null(results_folder)){
    stop("Please supply a value for results_folder")
  }

  ##make input, figures and tables folders
  fig.dir <- paste(results_folder, "figures", sep="/")
  tab.dir <- paste(results_folder, "tables", sep="/")
  inp.dir <- paste(results_folder, "input", sep="/")
  if(!dir.exists(fig.dir))dir.create(fig.dir)
  if(!dir.exists(tab.dir))dir.create(tab.dir)
  if(!dir.exists(inp.dir))dir.create(inp.dir)

  monthLabels <- month.abb

  # Join rotation and pitch data into a single table ------------------------
  windData <- dplyr::left_join(windData_rotation,windData_pitch,by='windSpeed')
  windThreshold <- windData$windSpeed[min(which(windData$rotationSpeed != 0))]  ##GH change (ROTOR to rotationSpeed)

  # set the row names of the bird data and assign flapping/gliding ----------
  #row.names(BirdData) <-  BirdData$Species
  #### flapping or Gliding for collision risk sheet
  Flap_Glide <- ifelse (BirdData$Flight == "Flapping", 1, 2/pi)  ### <- DO WE NEED THIS?!?


  #### produces a data frame with number of hours daylight and night per month based on the latitude
  hours <- DayLength(Latitude)


  ##### bring in call functions needed to calculate collision risk along blade
  ### Turned off for Option 1 GH - Needs updating
  #source("scripts/PCollFunctions.r", local=T)


  # calculations ------------------------------------------------------------

  ##set progress bar
  #pb   <- txtProgressBar(1, iter*length(CRSpecies)*nrow(TurbineData), style=3)

  ###create overall results summary table###
  resultsSummary = data.frame(matrix(data = 0, ncol = 8, nrow = length(CRSpecies)*nrow(TurbineData)))
  names(resultsSummary) = c("Species", "Turbine", "Option", "Mean", "SD","CV", "Median", "IQR")

  # Start of the species loop -----------------------------------------------

  for (s in 1 : length (CRSpecies)){
    ###CREATE BIRD PARAMETER DATA FRAME###
    sampledBirdParams = data.frame(matrix(data = 0, ncol = 7, nrow = iter))
    names(sampledBirdParams) = c("AvoidanceBasic", "AvoidanceExtended",  "WingSpan", "BodyLength", "PCH", "FlightSpeed", "NocturnalActivity")

    ###CREATE COUNT/DENSITY DATA FRAME###
    sampledSpeciesCount = data.frame(matrix(data = 0, ncol = 12, nrow = iter))
    names(sampledSpeciesCount) = month.abb

    ###CREATE DATA FRAME FOR DENSITY DATA###
    densitySummary=data.frame(matrix(data = 0, ncol = nrow(TurbineData)*3, nrow = iter))


    #### BC ##### -- progress bar update for iterations    ===========
    #if (is.function(updateProgress_Spec)) {
    #  text <- gsub("_", " ", CRSpecies[s])
    #  updateProgress_Spec(value = s/(length(CRSpecies)), detail = text)
    #}

    species.dat = subset (BirdData, Species == CRSpecies[s])

    species.dat$FlightNumeric <- ifelse(species.dat$Flight == 'Flapping', 1, 0)
    Flap_Glide = ifelse (species.dat$Flight == "Flapping", 1, 2/pi)


    #c_densOpt <-  ##dplyr::filter(DensityOpt, specLabel == CRSpecies[s])$userOption  ### <- work on this

    if(c_densOpt == "truncNorm"){
      species.count = subset(CountData, Species == CRSpecies[s])
    }


    if(c_densOpt == "reSamp"){
      species.count <- data.table::fread("data/birdDensityData_samples.csv") %>%
        dplyr::filter(specLabel == CRSpecies[s])
    }


    if(c_densOpt == "pcntiles"){
      species.count <- data.table::fread("data/birdDensityData_refPoints.csv") %>%
        dplyr::filter(specLabel == CRSpecies[s])
    }



    # ##input flight curves for the species
    # #################################
    # #### TURNED OFF FOR OPTION 1 ####
    #
    # ht<-paste("data/", CRSpecies[s],"_ht.csv", sep='')
    #
    # FlightHeightSpec <- read.csv(ht, header = T) #and change in option2 code
    #
    # flight.boot <- 2:dim(FlightHeightSpec)[2]     ##### BC CHANGE  -- need to skip first column with heights ######
    #
    # flight.boot.sample <- sample(flight.boot, iter, replace=T)
    ###########################################################################################


    ##add names of columns later in turbine loop###


    # Sample the bird attributes ----------------------------------------------
    ### Streamlined by GH 19 July 2021.
    sampledBirdParams$WingSpan <- sampler_hd(dat = species.dat$WingspanSD,
                                             mode = 'rtnorm',
                                             n = iter,
                                             mean=species.dat$Wingspan,
                                             sd = species.dat$WingspanSD,
                                             lower = 0)

    sampledBirdParams$BodyLength <- sampler_hd(dat = species.dat$Body_LengthSD,
                                               mode = 'rtnorm',
                                               n = iter,
                                               mean=species.dat$Body_Length,
                                               sd = species.dat$Body_LengthSD,
                                               lower = 0)


    sampledBirdParams$FlightSpeed <- sampler_hd(dat = species.dat$Flight_SpeedSD,
                                                mode = 'rtnorm',
                                                n = iter,
                                                mean=species.dat$Flight_Speed,
                                                sd = species.dat$Flight_SpeedSD,
                                                lower = 0)

    sampledBirdParams$PCH <- sampler_hd(dat = species.dat$Prop_CRH_ObsSD,
                                        mode = 'rbeta',
                                        n = iter,
                                        mean=species.dat$Prop_CRH_Obs,
                                        sd = species.dat$Prop_CRH_ObsSD)


    sampledBirdParams$NocturnalActivity <- sampler_hd(dat = species.dat$Nocturnal_ActivitySD,
                                                      mode = 'rbeta',
                                                      n = iter,
                                                      mean=species.dat$Nocturnal_Activity,
                                                      sd = species.dat$Nocturnal_ActivitySD)


    sampledBirdParams$AvoidanceBasic <- sampler_hd(dat = species.dat$AvoidanceBasicSD,
                                                   mode = 'rbeta',
                                                   n = iter,
                                                   mean=species.dat$AvoidanceBasic,
                                                   sd = species.dat$AvoidanceBasicSD)

    sampledBirdParams$AvoidanceExtended <- sampler_hd(dat = species.dat$AvoidanceExtendedSD,
                                                      mode = 'rbeta',
                                                      n = iter,
                                                      mean=species.dat$AvoidanceExtended,
                                                      sd = species.dat$AvoidanceExtendedSD)



    # Monthly density estimates sampled here --------------------------------------------

    if(c_densOpt == "truncNorm"){
      for(currentMonth in month.abb){
        # separate out the current month mean and SD. Species.count is already filtered for current species
        workingMean <- species.count %>% dplyr::select(contains(currentMonth),-contains('SD'))
        workingSD <- species.count %>% dplyr::select(contains(paste0(currentMonth,"SD")))
        sampledSpeciesCount[,grep(currentMonth, names(sampledSpeciesCount))] <- sampler_hd(dat = data.frame(workingSD)[1,1],
                                                                                           mode = 'rtnorm',
                                                                                           n = iter,
                                                                                           mean=data.frame(workingMean)[1,1],
                                                                                           sd = data.frame(workingSD)[1,1])
      }
    }


    if(c_densOpt == "reSamp"){
      for(currentMonth in monthLabels){
        workingVect <- dplyr::sample_n(tbl = species.count %>% dplyr::select(contains(currentMonth)), size = iter, replace = TRUE)
        sampledSpeciesCount[,grep(currentMonth, names(sampledSpeciesCount))] <- workingVect
      }
    }



    if(c_densOpt == "pcntiles"){
      for(currentMonth in monthLabels){
        cPcntls <- species.count %>% dplyr::select(referenceProbs, contains(currentMonth))
        workingVect <- sampleCount_pctiles(iter, probs = cPcntls[, 1], countsPctls = cPcntls[, 2])
        sampledSpeciesCount[,grep(currentMonth, names(sampledSpeciesCount))] <- workingVect
      }
    }


    # Start of turbine loop ---------------------------------------------------
    for (j in 1:nrow(TurbineData))  {   ## GH CHANGE <- t is a function, replaced this with j

      ### Number of turbines of given Output required to produce target output
      NTurbines = round (TPower / TurbineData$TurbineModel[j])

      ## create results tables - 3 identical
      tab1 <- data.frame(matrix(data = 0, ncol = 12, nrow = iter))
      names(tab1) <- monthLabels
      tab2 <- tab3 <- tab1

      ###set vectors to store PCol and CollInt###
      sampledPColl <- data.frame(matrix(data = 0, ncol = 1, nrow = iter))
      names(sampledPColl) <- "PColl"

      sampledCollInt <- data.frame(matrix(data = 0, ncol = 1, nrow = iter))
      names(sampledCollInt) <- "CollInt"

      ## GH streamlined code to a function where the row gets passed in for sampling
      sampledTurbine <- sample_turbine(TurbineData[j,],
                                       windSpeedMean = windSpeedMean,
                                       windSpeedSD = windSpeedSD,windData,windThreshold,iter)

      MonthlyOperational <- sampledTurbine %>% select(contains("Op", ignore.case = F))
      MeanOperational <- apply(MonthlyOperational, 1, mean)

      # Iterating i - over random samples  --------------------------------------

      for (i in 1:iter){

        #### BC ##### -- progress bar update for iterations    ===========
        #if (is.function(updateProgress_Iter)) {
        #  text <- NULL # paste0("Working through iteration ", i)
        #  updateProgress_Iter(value = i/iter, detail = text)
        #}

        # Collision risk steps - options appear here ------------------------------

        ############## STEP ONE - Calculate the collision risk in the absence of avoidance action

        P_Collision <- probability_collision_no_avoid(sampledBirdParams=sampledBirdParams[i,],
                                                      sampledTurbine=sampledTurbine[i,],
                                                      TurbineData=TurbineData[j,],
                                                      Prop_Upwind=Prop_Upwind,
                                                      Flap_Glide=Flap_Glide)


        ############## STEP TWO - Calculate Flux Factor - the number of birds passing a turbine in each month

        hours <- initial_flux(NTurbines=NTurbines,
                              sampledTurbine=sampledTurbine[i,],
                              sampledBirdParams=sampledBirdParams[i,],
                              sampledSpeciesCount=sampledSpeciesCount[i,],
                              TPower=TPower,
                              hours=hours)

        ############## STEP THREE - Calculate Large Array Correction Factor


        L_ArrayCF <- large_array_correction(NTurbines=NTurbines,
                                            sampledTurbine=sampledTurbine[i,],
                                            sampledBirdParams=sampledBirdParams[i,],
                                            P_Collision=P_Collision,
                                            MeanOperational=MeanOperational[i],
                                            WFWidth=WFWidth)

        # Option 1 ----------------------------------------------------------------


        #######################		Do model using option 1 - Site specific flight height information	###############################

        #source("scripts/Option1.r", local=T)


        Option1_CollisionRate <- sCRM_option1(MonthlyOperational=MonthlyOperational[i,],
                                              hours=hours,
                                              PCH=sampledBirdParams$PCH[i],
                                              P_Collision = P_Collision,
                                              AvoidanceBasic=sampledBirdParams$AvoidanceBasic[i],
                                              LargeArrayCorrection=LargeArrayCorrection,
                                              L_ArrayCF=L_ArrayCF)


        #         Option1_CollisionRate_2 <- get_collisions_basic(n_transits = n_transits,
        #                                                         prob_single_collision = P_Collision,
        #                                                         prop_time_operating = MonthlyOperational[i,],
        #                                                         avoidance_rate = sampledBirdParams$AvoidanceBasic[i],
        #                                                         lac_factor = L_ArrayCF)



        ## add results to overall species/turbine results table
        tab1[i,]=Option1_CollisionRate[,2]
        #store P_Coll
        sampledPColl[i,]<-P_Collision/100


        # Option 2 ----------------------------------------------------------------


        #######################		Do model using option 2 - modelled flight height distribution		###############################
        #source("scripts/Option2.r", local=T)
        ## add results to overall species/turbine results table
        #tab2[i,]=Option2_CollisionRate[,2]
        # Option 3 ----------------------------------------------------------------
        #######################		Do model using option 3 - modelled flight height distribution		###############################
        #######################		taking account of variation in risk along the rotor blades		###############################
        #source("scripts/Option3.r", local=T)
        ## add results to overall species/turbine results table
        #tab3[i,]=Option3_CollisionRate[,2]
        #Store Collision Integral
        #sampledCollInt[i,]<-CollInt
        ##progress bar for iterations##
        #setTxtProgressBar(pb, s*t+i)
        #setTxtProgressBar(pb, (s*nrow(TurbineData)-(nrow(TurbineData)-t))*iter-(iter-i))


      } # end of i to iter

      # End of the random sampling iterations i --------------------------------


      #source("scripts/turbineSpeciesOuputs.r", local=T)

      #### BC ##### -- reset counter of progress bar for iterations =====================
      #if (is.function(updateProgress_Iter)) {
      #  text <- NULL # paste0("Working through iteration ", i)
      #  updateProgress_Iter(value = 0, detail = text)
      #}


      #### BC ##### -- Store simulation replicates under each option, for current species and turbine  ===========
      cSpec <- CRSpecies[s]
      cTurbModel <- paste0("turbModel", TurbineData$TurbineModel[j])

      monthCollsnReps_opt1[[cSpec]][[cTurbModel]] <- tab1
      #monthCollsnReps_opt2[[cSpec]][[cTurbModel]] <- tab2
      #monthCollsnReps_opt3[[cSpec]][[cTurbModel]] <- tab3

    } # end of j over number of turbine


    # End of the turbine loop -------------------------------------------------

    ###output species plots of density by option with curves for turbine model###
    ###PLOT DENSITY BY OPTION (useful if several turbine models)###

    #if (nrow(TurbineData)>1)  {
    #source("scripts/species_turbine_plots.r", local = T)
    #}

    ###relabel sampledBirdParams by species name###
    assign(paste(CRSpecies[s],"params", sep="_"), sampledBirdParams)

    ###relabel sampledSpeciesCount by species name###
    assign(paste(CRSpecies[s],"counts", sep="_"), sampledSpeciesCount)


  } # end of the species loop over s

  ##output input data##
  data.table::fwrite(BirdData, paste(results_folder,"input", "BirdData.csv", sep="/"))
  data.table::fwrite(CountData, paste(results_folder,"input", "birdDensityData.csv", sep="/"))      # <<<<< BC <<<<<  change of file name, for clarity
  data.table::fwrite(TurbineData, paste(results_folder,"input", "TurbineData.csv", sep="/"))

  ###output results table###
  data.table::fwrite(resultsSummary, paste(results_folder,"tables", "CollisionEstimates.csv", sep="/"))


  end.time <- Sys.time()
  run.time <- end.time - start.time
  run.time

  sink(paste(results_folder,"run.time.txt", sep="/"))
  print(run.time)
  print(paste("The model ran", iter,"iterations", sep=" "))
  print("The following species were modelled:")
  print(CRSpecies)
  print("The following turbines were modelled:")
  print(TurbineData$TurbineModel)
  sink()

  #### BC ##### -- return collision replicates as output  ===========
  return(list(monthCollsnReps_opt1 = monthCollsnReps_opt1))#, monthCollsnReps_opt2 = monthCollsnReps_opt2,#monthCollsnReps_opt3 = monthCollsnReps_opt3))


}

